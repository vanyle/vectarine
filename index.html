<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<title>Vectarine Web Build</title>
		<style>
			html,
			body {
				margin: 0;
				padding: 0;
				width: 100vw;
				height: 100vh;
				overflow: hidden;
			}

			.loading-info {
				z-index: 1;
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
			}

			/* the canvas *must not* have any border or padding, or mouse coords will be wrong */
			canvas {
				border: 0px none;
				position: absolute;
				top: 0;
				left: 0;
				width: 100vw;
				height: 100vh;
				background-color: black;
			}

			#status {
				color: white;
				font-family: Arial, sans-serif;
				font-size: 24px;
				text-shadow: 1px 1px 3px 2px #eee;
			}

			.loading-info {
				display: flex;
				flex-direction: column;
				row-gap: 16px;
				align-items: center;
			}

			.spinner {
				height: 30px;
				width: 30px;
				margin: 0;
				margin-top: 20px;
				margin-left: 20px;
				display: inline-block;
				vertical-align: top;
				animation: rotation 0.8s linear infinite;
				border-left: 5px solid rgb(235, 235, 235);
				border-right: 5px solid rgb(235, 235, 235);
				border-bottom: 5px solid rgb(235, 235, 235);
				border-top: 5px solid rgb(120, 120, 120);
				border-radius: 100%;
				background-color: rgb(189, 215, 46);
			}

			@keyframes rotation {
				from {
					transform: rotate(0deg);
				}

				to {
					transform: rotate(360deg);
				}
			}
		</style>
	</head>

	<body>
		<div id="loading-info" class="loading-info">
			<div class="spinner" id="spinner"></div>
			<div class="emscripten" id="status">Downloading...</div>
		</div>

		<canvas
			class="emscripten"
			id="canvas"
			oncontextmenu="event.preventDefault()"
		></canvas>
		<script>
			function read_file_for_rust(o) {
				const filename = o.filename;
				const callback = o.callback;
				(async () => {
					try {
						const response = await fetch(filename);
						if (response.status >= 400) {
							callback(false);
							return;
						}
						const blob = await response.blob();
						const reader = new FileReader();
						reader.readAsDataURL(blob);
						reader.onloadend = function () {
							const base64data = reader.result.split(",")[1];
							if (base64data.length >= 4_000_000) {
								console.warn(
									`File ${filename} too large (${base64data.length} > 4.000.000) to read (WASM might refuse to allocate this much memory to store it): `
								);
								callback(false);
							} else {
								try {
									callback(base64data); // This always throws to catch the execution flow
								} catch (err) {}
							}
						};
					} catch (err) {
						console.error("Error fetching file:");
						console.log(err);
						callback(false);
					}
				})();
			}

			const canvas = document.getElementById("canvas");
			window.vectarine = {
				read_file_for_rust: read_file_for_rust,
				getScreenSize: function () {
					return {
						width: canvas.clientWidth,
						height: canvas.clientHeight,
					};
				},
				getDrawableScreenSize: function () {
					return {
						width: canvas.width,
						height: canvas.height,
					};
				},
			};

			const loadingInfoElement = document.getElementById("loading-info");
			const statusText = document.getElementById("status");
			var Module = {
				preRun: [],
				postRun: [],
				print: (function () {
					return function (text) {
						if (arguments.length > 1)
							text = Array.prototype.slice
								.call(arguments)
								.join(" ");
						// These replacements are necessary if you render to raw HTML
						console.log("[WASM]", ...arguments);
					};
				})(),
				printErr: function (text) {
					if (arguments.length > 1)
						text = Array.prototype.slice.call(arguments).join(" ");
					if (0) {
						// XXX disabled for safety typeof dump == 'function') {
						dump(text + "\n"); // fast, straight to the real console
					} else {
						console.error(text);
						if (text.startsWith("fatal runtime error")) {
							// Stop the module on fatal errors
							// This avoid spamming the console with unrelevant errors
							Module.abort();
						}
					}
				},
				canvas: (function () {
					var canvas = document.getElementById("canvas");
					// As a default initial behavior, pop up an alert when webgl context is lost. To make your
					// application robust, you may want to override this behavior before shipping!
					// See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15.2
					canvas.addEventListener(
						"webglcontextlost",
						function (e) {
							alert(
								"WebGL context lost. You will need to reload the page."
							);
							e.preventDefault();
						},
						false
					);
					return canvas;
				})(),
				setStatus: function (text) {
					if (!Module.setStatus.last)
						Module.setStatus.last = { time: Date.now(), text: "" };
					if (text === Module.setStatus.text) return;
					var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
					var now = Date.now();
					if (m && now - Date.now() < 30) return; // if this is a progress update, skip it if too soon

					//console.trace("Status: ", text);
					if (text.trim() === "Running...") {
						loadingInfoElement.style.display = "none";
					}
				},
				totalDependencies: 0,
				monitorRunDependencies: function (left) {
					this.totalDependencies = Math.max(
						this.totalDependencies,
						left
					);
					Module.setStatus(
						left
							? "Preparing... (" +
									(this.totalDependencies - left) +
									"/" +
									this.totalDependencies +
									")"
							: "All downloads complete."
					);
				},
			};
			Module.setStatus("Downloading...");
			window.onerror = function (event) {
				// TODO: do not warn on ok events like simulating an infinite loop or exitStatus
				Module.setStatus("Exception thrown, see JavaScript console");
				//loadingInfoElement.style.display = "none";
				Module.setStatus = function (text) {
					if (text)
						Module.printErr("[post-exception status] " + text);
				};
			};

			function scriptLoadError() {
				statusText.textContent =
					"Error loading runtime, is the file there?";
			}
			addEventListener("load", () => {
				let script = document.createElement("script");
				script.onerror = scriptLoadError;
				script.src =
					"target/wasm32-unknown-emscripten/release/runtime.js";
				document.head.appendChild(script);
			});
		</script>
	</body>
</html>
